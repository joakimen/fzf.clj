(ns fzf.impl-test
  (:require [fzf.impl :as i]
            [clojure.test :as t]
            [clojure.string :as str]))

(def ^:private dummy-bbnc-path "DUMMY_BBNC_PATH_FOR_TESTING") ; For tests needing a bbnc path

(t/deftest parse-opts-test
  (t/testing "no options produce expected defaults"
    (t/is (= {:cmd ["fzf"], :opts {:in :inherit, :out :string, :err :inherit}}
             (i/parse-opts {} [] nil nil)))) ; Pass nil for server-port and bbnc-script-path
  (t/testing "adding fzf flags produce correct command string"
    (t/is (= ["fzf" "--multi" "--reverse" "--tac" "-i" "--exact" "--preview" "echo {}" "--header" "header-text" "--header-lines" "2" "--header-first" "--height" "10%" "--select-1" "--query" "one"] ; header-lines is "2"
             (:cmd (i/parse-opts {:multi true
                                  :reverse true
                                  :tac true
                                  :case-insensitive true
                                  :exact true
                                  :preview "echo {}"
                                  :header {:header-str "header-text"
                                           :header-lines 2 ; Will be stringified
                                           :header-first true}
                                  :height "10%"
                                  :throw true ; This option is used by fzf.impl/fzf, not parse-opts directly for cmd generation
                                  :select-1 true
                                  :query "one"}
                                 []
                                 nil nil))))) ; Pass nil for server-port and bbnc-script-path
  (t/testing "additional-bindings are correctly added to command"
    (t/is (= ["fzf" "--bind" "ctrl-a:accept"]
             (:cmd (i/parse-opts {:additional-bindings ["ctrl-a:accept"]} [] nil nil))))
    (t/is (= ["fzf" "--bind" "ctrl-a:accept" "--bind" "ctrl-b:reload(ls)"]
             (:cmd (i/parse-opts {:additional-bindings ["ctrl-a:accept" "ctrl-b:reload(ls)"]} [] nil nil))))
    (t/is (= ["fzf"] ; No bindings if :additional-bindings is empty
             (:cmd (i/parse-opts {:additional-bindings []} [] nil nil))))
    (t/is (= ["fzf" "--multi" "--bind" "ctrl-x:accept"] ; Ensure other flags are preserved
             (:cmd (i/parse-opts {:multi true :additional-bindings ["ctrl-x:accept"]} [] nil nil)))))

  (t/testing "command-bindings are correctly formatted and added to command"
    (t/testing "single simple action"
      (t/is (= ["fzf" "--bind" "ctrl-x:accept"]
               (:cmd (i/parse-opts {:command-bindings {"ctrl-x" ["accept"]}} [] nil nil)))))
    (t/testing "multiple simple actions"
      (t/is (= ["fzf" "--bind" "ctrl-x:accept+clear-query"]
               (:cmd (i/parse-opts {:command-bindings {"ctrl-x" ["accept" "clear-query"]}} [] nil nil)))))
    (t/testing "action with :simple-arg"
      (t/is (= ["fzf" "--bind" "ctrl-p:change-prompt(NewPrompt> )"]
               (:cmd (i/parse-opts {:command-bindings {"ctrl-p" [{:action-name "change-prompt" :simple-arg "NewPrompt> "}]}} [] nil nil)))))
    (t/testing "action with :command-string"
      (t/is (= ["fzf" "--bind" "ctrl-e:execute(ls -l)"]
               (:cmd (i/parse-opts {:command-bindings {"ctrl-e" [{:action-name "execute" :command-string "ls -l"}]}} [] nil nil)))))
    (t/testing "action with :handler-fn (symbol)"
      (let [handler-form 'my-app.core/handle-this
            ;; Reconstruct the expected string part generated by format-action-spec
            bb-eval-str (i/build-babashka-eval-string handler-form)
            escaped-bb-eval-str (str/replace bb-eval-str "'" "'\\''")
            expected-action-str (str "reload(bb -e '" escaped-bb-eval-str "')")]
        (t/is (= ["fzf" "--bind" (str "ctrl-r:" expected-action-str)]
                 (:cmd (i/parse-opts {:command-bindings {"ctrl-r" [{:action-name "reload"
                                                                    :handler-fn handler-form}]}}
                                   [] nil nil))))))
    (t/testing "action with :handler-fn (string containing Clojure code)"
      (let [handler-code-str "(fn [lines] (mapv clojure.string/upper-case lines))"
            bb-eval-str (i/build-babashka-eval-string handler-code-str)
            escaped-bb-eval-str (str/replace bb-eval-str "'" "'\\''")
            expected-action-str (str "transform-header(bb -e '" escaped-bb-eval-str "')")]
        (t/is (= ["fzf" "--bind" (str "alt-t:" expected-action-str)]
                 (:cmd (i/parse-opts {:command-bindings {"alt-t" [{:action-name "transform-header"
                                                                   :handler-fn handler-code-str}]}}
                                   [] nil nil))))))
    (t/testing "action map with only :action-name (no argument)"
      (t/is (= ["fzf" "--bind" "esc:abort"]
               (:cmd (i/parse-opts {:command-bindings {"esc" [{:action-name "abort"}]}} [] nil nil)))))
    (t/testing "multiple command-bindings keys"
      (t/is (= ["fzf" "--bind" "ctrl-a:accept" "--bind" "ctrl-b:cancel"]
               (:cmd (i/parse-opts {:command-bindings {"ctrl-a" ["accept"]
                                                       "ctrl-b" ["cancel"]}}
                                   [] nil nil)))))
    (t/testing "empty :command-bindings map"
      (t/is (= ["fzf"]
               (:cmd (i/parse-opts {:command-bindings {}} [] nil nil)))))
    (t/testing "command-bindings combined with other flags"
      (t/is (= ["fzf" "--multi" "--bind" "ctrl-x:accept"]
               (:cmd (i/parse-opts {:multi true
                                     :command-bindings {"ctrl-x" ["accept"]}}
                                   [] nil nil))))))
  (t/testing "adding :preview-fn produces command string with inline bb netcat script"
    (let [test-port 12345]
      (t/is (= ["fzf" "--preview" (i/bbnc-preview-command dummy-bbnc-path test-port)] ; Use 2-arg bbnc-preview-command
               (:cmd (i/parse-opts {:preview-fn (fn [_] "preview-fn")}
                                   []
                                   test-port dummy-bbnc-path)))))) ; Pass test-port and dummy-bbnc-path
  (t/testing "providing input-arguments maps them to process stdin"
    (t/is (= {:in "one\ntwo\nthree", :out :string, :err :inherit}
             (:opts (i/parse-opts {} ["one" "two" "three"] nil nil))))
    (t/is (= {:in "1\n2\n3", :out :string, :err :inherit}
             (:opts (i/parse-opts {} [1 2 3] nil nil))))
    (t/is (= {:in ":one\n:two\n:three", :out :string, :err :inherit}
             (:opts (i/parse-opts {} [:one :two :three] nil nil)))))
  (t/testing "providing no input-arguments should retain default proc options"
    (t/is (= {:in :inherit, :out :string, :err :inherit}
             (:opts (i/parse-opts {} [] nil nil)))))
  (t/testing "option for startup-dir to correctly mapped to process options"
    (t/is (= {:in :inherit, :out :string, :err :inherit, :dir "/tmp"}
             (:opts (i/parse-opts {:dir "/tmp"} [] nil nil))))))
